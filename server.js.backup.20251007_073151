const express = require("express");
const cors = require("cors");  // npm i cors for cross-origin (frontend:3000)
const http = require("http");
const socketIo = require("socket.io");  // npm i socket.io
const fs = require("fs").promises;
const cron = require("node-cron");  // npm i node-cron for background job
const { exec } = require("child_process");  // For running Python
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");  // npm i @aws-sdk/client-secrets-manager for v3

// AWS Secrets Manager v3 setup
const client = new SecretsManagerClient({ region: 'eu-north-1' });  // Your region (Stockholm)

// Load creds from AWS on startup (your full .env as JSON from vault)
let creds = {};  // Global for use in endpoints
const loadSecrets = async () => {
  // Skip AWS in local development
  if (process.env.NODE_ENV !== 'production') {
    console.log('Local development mode - using mock credentials');
    creds = {};  // Use fallback emails in channelData
    return;
  }
  
  try {
    const command = new GetSecretValueCommand({ SecretId: 'prod/podcasts/creds' });
    const data = await client.send(command);
    creds = JSON.parse(data.SecretString);
    console.log('Full secrets loaded from AWS Secrets Manager v3 (50 channels)');
  } catch (error) {
    console.error('Failed to load secrets:', error);
    creds = {};  // Fallback empty—use mocks for local
  }
};
loadSecrets();  // Run on start

const app = express();
const server = http.createServer(app);  // http for Socket.io
const io = socketIo(server, { cors: { origin: true } });  // CORS for frontend - allow all origins in dev

app.use(express.json());
app.use(cors({ origin: true }));  // Allow all origins for Codespaces

// Root endpoint
app.get("/", (req, res) => {
  res.json({
    message: "Podcast API Server",
    version: "1.0.0",
    endpoints: {
      health: "/api/health",
      feeds: "/api/feeds",
      statuses: "/api/statuses",
      metadata: "/api/metadata/:id (e.g., /api/metadata/ONE)"
    },
    status: "running"
  });
});

// Metadata endpoint (your resilient version, with AWS creds for emails)
app.get("/api/metadata/:id", async (req, res) => {
  try {
    // Read feeds first (critical)
    let feeds;
    try {
      feeds = JSON.parse(await fs.readFile("feeds.json"));
    } catch (fileError) {
      return res.status(500).json({ message: "feeds.json missing/corrupt" });
    }

    // Read statuses with fallback
    let statuses = [];
    try {
      statuses = JSON.parse(await fs.readFile("statuses.json"));
    } catch (statusError) {
      console.warn("statuses.json missing—using pending fallback");
      // No return 500—proceed with pending status
    }

    const id = req.params.id;

    // Find feed (always exists or 404)
    const feed = feeds.find((f) => f.channel === id);
    if (!feed) {
      return res.status(404).json({ message: "Metadata not found" });
    }

    // Find status or fallback to pending
    const status = statuses.find((s) => s.channel === id) || { 
      status: "pending", 
      checked_at: "N/A" 
    };

    // Full lengthy mock channels.xlsx data (your history; emails from AWS creds or fallback)
    const channelData = {
      ONE: {
        email: creds.AMAZON_CH1_EMAIL || "member@rhythmaura.digital",
        brandName: "The Emmanuelatere2000's Podcast",
        dateCreated: "24-09-2025",
        dateSubmitted: "24-09-2025",
        link: "https://music.amazon.co.uk/podcasts/c40177c1-4854-4ef6-bff0-9742e23db7fe/the-emmanuelatere2000s-podcast"
      },
      TWO: {
        email: creds.AMAZON_CH2_EMAIL || "admin@vibehaven.life",
        brandName: "First Ever",
        dateCreated: "24-09-2025",
        dateSubmitted: "24-09-2025",
        link: "https://music.amazon.co.uk/podcasts/e98af407-64c1-410e-9427-a5acdecd4c69/first-ever"
      },
      THREE: {
        email: creds.AMAZON_CH3_EMAIL || "music@sonicwave.quest",
        brandName: "WINNER",
        dateCreated: "25-09-2025",
        dateSubmitted: "25-09-2025",
        link: "https://music.amazon.co.uk/podcasts/9d5b04c1-f84f-4c29-9021-2730081ddbf6"
      },
      FOUR: {
        email: creds.AMAZON_CH4_EMAIL || "studio@melodydock.shop",
        brandName: "The ateree91's Podcast",
        dateCreated: "25-09-2025",
        dateSubmitted: "25-09-2025",
        link: "https://music.amazon.co.uk/podcasts/..."
      }
      // Add more channels (FIVE through FIFTY) as needed
    };

    // Get metadata or fallback
    const metadata = channelData[id];
    
    // Combine all data
    res.json({
      ...feed,
      ...status,
      history: metadata || { 
        email: "unknown", 
        brandName: "Unknown", 
        dateCreated: "N/A", 
        dateSubmitted: "N/A",
        link: "N/A"
      }
    });
    
  } catch (error) {
    console.error("Metadata endpoint error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
});

// Socket.io connection handler
io.on("connection", (socket) => {
  console.log("Client connected:", socket.id);
  
  socket.on("disconnect", () => {
    console.log("Client disconnected:", socket.id);
  });
});

// Background job to check statuses (every 5 minutes)
// Uncomment when check_status.py is ready
/*
cron.schedule("*\/5 * * * *", async () => {
  console.log("Running background status check...");
  
  exec("python3 check_status.py", (error, stdout, stderr) => {
    if (error) {
      console.error("Status check error:", error);
      return;
    }
    console.log("Status check complete:", stdout);
    
    // Emit update to all connected clients
    io.emit("status-update", { message: "Statuses updated" });
  });
});
*/

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.json({ status: "ok", timestamp: new Date().toISOString() });
});

// Get all feeds endpoint
app.get("/api/feeds", async (req, res) => {
  try {
    const feeds = JSON.parse(await fs.readFile("feeds.json"));
    res.json(feeds);
  } catch (error) {
    console.error("Error reading feeds:", error);
    res.status(500).json({ message: "Error reading feeds", error: error.message });
  }
});

// Get all statuses endpoint
app.get("/api/statuses", async (req, res) => {
  try {
    const statuses = JSON.parse(await fs.readFile("statuses.json"));
    res.json(statuses);
  } catch (error) {
    console.error("Error reading statuses:", error);
    res.status(500).json({ message: "Error reading statuses", error: error.message });
  }
});

// Start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Socket.io ready for connections`);
});